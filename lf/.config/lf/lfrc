set ratios 1:2:3

# Basic vars
set shell zsh
set shellopts '-euy'
set ifs "\n"
set filesep "\n"  # default already
set scrolloff 10
set icons
set hidden true
set period 1
set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml"
set previewer ~/.config/lf/preview
set cleaner ~/.config/lf/cleaner

cmd open ${{
    case $(file --mime-type $f -b) in
	image/vnd.djvu|application/pdf|application/octet-stream) setsid -f zathura $fx >/dev/null 2>&1 ;;
        text/*|application/json) $EDITOR $fx;;
	image/x-xcf) setsid -f gimp $f >/dev/null 2>&1 ;;
	image/svg+xml) display -- $f ;;
	image/*) rotdir $f | grep -i "\.\(png\|jpg\|jpeg\|gif\|webp\|tif\|ico\)\(_large\)*$" | sxiv -aio 2>/dev/null | lf-select ;;
	audio/*) mpv --audio-display=no $f ;;
	video/*) setsid -f mpv $f -quiet >/dev/null 2>&1 ;;
	application/pdf|application/vnd*|application/epub*) setsid -f zathura $fx >/dev/null 2>&1 ;;
        *) for f in $fx; do setsid -f $OPENER $f >/dev/null 2>&1; done;;
    esac
}}

cmd mkdir %mkdir -p "$@"

cmd extract ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	printf "%s\n\t" "$fx"
	printf "extract?[y/N]"
	read ans
	[ $ans = "y" ] && ext $fx
	clear
}}

cmd delete ${{
	clear; tput cup $(($(tput lines)/3)); tput bold
	set -f
	printf "%s\n\t" "$fx"
	printf "delete?[y/N]"
	read ans
	[ $ans = "y" ] && rm -rf -- $fx
	clear
}}

cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        # symbolically copy mode is indicating a soft link
        copy) ln -sr -t . -- "$@";;
        # while a move mode is indicating a hard link
        move) ln -t . -- "$@";;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}

cmd select-files ${{
    { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type f; } |
        if [ "$lf_hidden" = "false" ]; then
          # remove any hidden files so you only select files you can see.
          grep -v '/\.[^/]\+$'
        else
          cat
        fi |
        sed '/^$/d' | sort | uniq -u |
        xargs -d '\n' -r -I{} lf -remote "send $id toggle {}"
}}

cmd fzf_search ${{
    res="$( \
        RG_PREFIX="rg --column --line-number --no-heading --color=always \
            --smart-case "
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1
    )"
    [ ! -z "$res" ] && lf -remote "send $id select \"$res\""
}}

cmd fzf_jump ${{
    res="$(find . | fzf --reverse --header='Jump to location' | sed 's/\\/\\\\/g;s/"/\\"/g')"
    if [ -d "$res" ]; then
        cmd="cd"
    else 
        cmd="select"                                                       
    fi
    lf -remote "send $id $cmd \"$res\""
}}

cmd poetry_lvim ${{
  cd $fx
  poetry run lvim .
}}

cmd setbg "$1"
cmd bulkrename $vidir
cmd share $curl -F"file=@$fx" https://0x0.st | xclip -selection c
cmd docxToPdf $libreoffice --headless --convert-to pdf $fx
cmd trash %trash-put $fx

# Bindings
map <c-a> :select-files
map gg top
map gS :share
map gd :delete
map gs :fzf_search
map gf :fzf_jump
map gc $code $fx
map gl $lvim $fx
map gp :poetry_lvim
map D :trash
map t toggle
map A push :mkdir<space>
map a push $lvim<space>
map <c-r> reload
map <enter> shell
map x $$f
map X !$f
map o &open $f
map O $mimeopen --ask $f

map <c-z> $kill -STOP $PPID
map <c-p> :docxToPdf
map <c-e> extract
map B bulkrename
map b $setbg $f

cmd paste_try_cow &{{
    # # This was very helpful for debugging:
    # log_file="$HOME/lf-reflink-log-$(date +'%Y-%m-%d_%H-%M-%S')"
    # [ -f "$log_file" ] || touch "$log_file"
    # exec 1>> $log_file 2>&1
    # set -x

    # In theory, this may fail,
    # but I tested it on selection with 10k files - everything worked (bash)
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift

    if [ $mode = 'copy' ]; then
        # Reflink if all items of selection and the destination are on the
        # same mount point and it is CoW fs.
        # (to make sure reflink never fails in first place, so we don't have to
        # clean up)

        src_targets="$(df --output=target -- "$@" | sed '1d' | sort -u)"

        if [ "$(df --output=target -- "$PWD" | tail -n 1)" = \
             "$(echo "$src_targets" | tail -n 1)" ] && \
             (( "$(echo "$src_targets" | wc -l)" == 1 )) && \
             [[ "$(df --output=fstype -- "$PWD" | tail -n 1)" =~ ^(btrfs|xfs|zfs)$ ]]; then

            echo 'selected copy and cp reflink paste'

            start=$(date '+%s')

            # Handle same names in dst
            # TODO parallelism, idk - but exit/return/break won't stop the loop from subshell...
            for i in "$@"; do
                name="${i##*/}"
                original="$name"

                count=0
                while [ -w "$PWD/$name" ]; do
                    count=$((count+1))
                    name="$original.~$count~"
                done

                set +e
                cp_out="$(cp -rn --reflink=always -- "$i" "$PWD/$name" 2>&1)"
                set -e

                if [ ! -z "$cp_out" ]; then
                    lf -remote "send $id echoerr $cp_out"
                    exit 0
                fi
            done

            finish=$(( $(date '+%s') - $start ))
            t=''
            if (( $finish > 2 )); then
                t="${finish}s"
            fi

            # Or just skip a file when names are the same.
            # (A LOT faster if you e.g. pasting selection of 10k files)
            # cp -rn --reflink=always -- "$@" .

            lf -remote "send clear"

            green=$'\u001b[32m'
            reset=$'\u001b[0m'
            lf -remote "send $id echo ${green}reflinked!${reset} $t"
        else
            echo 'selected copy and lf native paste'
            lf -remote "send $id paste"
        fi

    elif [ $mode = 'move' ]; then
        echo 'selected move and lf native paste'
        lf -remote "send $id paste"
    fi

    # # for debug
    # set +x

    lf -remote "send load"
}}

# name is different to avoid recursive calls
map p paste_try_cow

# Source Bookmarks
source "~/.config/lf/shortcutrc"
