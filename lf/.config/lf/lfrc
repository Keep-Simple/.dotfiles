set ratios 1:2:3

# Basic vars
set shell zsh
set shellopts '-euy'
set ifs "\n"
set scrolloff 10
set icons
set hidden true
set period 1
set hiddenfiles ".*:*.aux:*.log:*.bbl:*.bcf:*.blg:*.run.xml"
set preview
set previewer ~/.config/lf/preview

cmd open ${{
    case $(file --mime-type $f -b) in
      text/*|application/json|application/octet-stream) $EDITOR $fx;;
      audio/*) mpv --audio-display=no $f ;;
      video/*) setsid -f mpv $f -quiet >/dev/null 2>&1 ;;
      # application/pdf|application/vnd*|application/epub*) setsid -f zathura $fx >/dev/null 2>&1 ;;
      *) for f in $fx; do open $f > /dev/null 2> /dev/null & done;;
    esac
}}

cmd mkdir %mkdir -p "$@"

cmd extract ${{
  set -f
  case $f in
    *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
    *.tar.gz|*.tgz) tar xzvf $f;;
    *.tar.xz|*.txz) tar xJvf $f;;
    *.tar) tar xvf $f;;
    *.zip) unzip $f;;
    *.rar) unrar x $f;;
    *.7z) 7z x $f;;
    *) echo "Unsupported format";;
  esac
}}

cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

cmd delete ${{
  set -f
  printf "\n$fx\n"
  printf "delete?[y/N]"
  read ans
  if [[ $ans == "y" ]]; then
    rm -rf $fx
  fi
}}

cmd chmod ${{
  printf "\nMode Bits: "
  read ans
  for file in "$fx"
  do
    chmod $ans $file
  done
  lf -remote 'send reload'
}}

cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        # symbolically copy mode is indicating a soft link
        copy) ln -sr -t . -- "$@";;
        # while a move mode is indicating a hard link
        move) ln -t . -- "$@";;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}

cmd select-files ${{
    { echo "$fs"; find -L "$(pwd)" -mindepth 1 -maxdepth 1 -type f; } |
        if [ "$lf_hidden" = "false" ]; then
          # remove any hidden files so you only select files you can see.
          grep -v '/\.[^/]\+$'
        else
          cat
        fi |
        sed '/^$/d' | sort | uniq -u |
        xargs -d '\n' -r -I{} lf -remote "send $id toggle {}"
}}

cmd fzf_search ${{
    res="$( \
        RG_PREFIX="rg --column --line-number --no-heading --color=always \
            --smart-case "
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1
    )"
    [ ! -z "$res" ] && lf -remote "send $id select \"$res\""
}}

cmd fzf_jump ${{
    res="$(find . | fzf --reverse --header='Jump to location' | sed 's/\\/\\\\/g;s/"/\\"/g')"
    if [ -d "$res" ]; then
        cmd="cd"
    else 
        cmd="select"                                                       
    fi
    lf -remote "send $id $cmd \"$res\""
}}

# Copy the file names (including extension) of the selections separated by \n
cmd copy-filename ${{
  names="$(echo $fx | tr ' ' '\n' | xargs -I{} basename {})"
  echo $names | tr ' ' '\n' | pbcopy
}}

# Copy the absolute paths of selections separated by \n
cmd copy-absolute-path ${{
  echo $fx | tr ' ' '\n' | pbcopy
}}

cmd poetry_lvim ${{
  cd $fx
  poetry run lvim .
}}



map gh
map d
map y
map ,

cmd setbg "$1"
cmd share $curl -F"file=@$fx" https://0x0.st | xclip -selection c
cmd docxToPdf $libreoffice --headless --convert-to pdf $fx
cmd trash %trash-put $fx

map yy copy
map yn copy-filename
map yP copy-absolute-path
map x cut
map X !$f
map gg top
map gd :delete
map ,st :fzf_search
map ,S :share
map ,ch :chmod
map ,f :fzf_jump
map ,t push :tar<space>
map ,e :extract
map gc $code $fx
map gl $lvim $fx
map gp :poetry_lvim
map D :trash
map t toggle
map A push :mkdir<space>
map a push $lvim<space>
map <c-r> reload
map <c-a> :select-files
map <enter> shell

map <c-z> $kill -STOP $PPID
map <c-p> :docxToPdf
map b $setbg $f

cmd paste_try_cow &{{
    # # This was very helpful for debugging:
    # log_file="$HOME/lf-reflink-log-$(date +'%Y-%m-%d_%H-%M-%S')"
    # [ -f "$log_file" ] || touch "$log_file"
    # exec 1>> $log_file 2>&1
    # set -x

    # In theory, this may fail,
    # but I tested it on selection with 10k files - everything worked (bash)
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift

    if [ $mode = 'copy' ]; then
        # Reflink if all items of selection and the destination are on the
        # same mount point and it is CoW fs.
        # (to make sure reflink never fails in first place, so we don't have to
        # clean up)

        src_targets="$(df --output=target -- "$@" | sed '1d' | sort -u)"

        if [ "$(df --output=target -- "$PWD" | tail -n 1)" = \
             "$(echo "$src_targets" | tail -n 1)" ] && \
             (( "$(echo "$src_targets" | wc -l)" == 1 )) && \
             [[ "$(df --output=fstype -- "$PWD" | tail -n 1)" =~ ^(btrfs|xfs|zfs)$ ]]; then

            echo 'selected copy and cp reflink paste'

            start=$(date '+%s')

            # Handle same names in dst
            # TODO parallelism, idk - but exit/return/break won't stop the loop from subshell...
            for i in "$@"; do
                name="${i##*/}"
                original="$name"

                count=0
                while [ -w "$PWD/$name" ]; do
                    count=$((count+1))
                    name="$original.~$count~"
                done

                set +e
                cp_out="$(cp -rn --reflink=always -- "$i" "$PWD/$name" 2>&1)"
                set -e

                if [ ! -z "$cp_out" ]; then
                    lf -remote "send $id echoerr $cp_out"
                    exit 0
                fi
            done

            finish=$(( $(date '+%s') - $start ))
            t=''
            if (( $finish > 2 )); then
                t="${finish}s"
            fi

            # Or just skip a file when names are the same.
            # (A LOT faster if you e.g. pasting selection of 10k files)
            # cp -rn --reflink=always -- "$@" .

            lf -remote "send clear"

            green=$'\u001b[32m'
            reset=$'\u001b[0m'
            lf -remote "send $id echo ${green}reflinked!${reset} $t"
        else
            echo 'selected copy and lf native paste'
            lf -remote "send $id paste"
        fi

    elif [ $mode = 'move' ]; then
        echo 'selected move and lf native paste'
        lf -remote "send $id paste"
    fi

    # # for debug
    # set +x

    lf -remote "send load"
}}
cmd bulk-rename ${{
  old="$(mktemp)"
  new="$(mktemp)"
  if [ -n "$fs" ]; then
    fs="$(basename $fs)"
  else
    fs="$(ls)"
  fi
  printf '%s\n' "$fs" >"$old"
  printf '%s\n' "$fs" >"$new"
  $EDITOR "$new"
  [ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
  paste "$old" "$new" | while IFS= read -r names; do
    src="$(printf '%s' "$names" | cut -f1)"
    dst="$(printf '%s' "$names" | cut -f2)"
    if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
        continue
    fi
    mv -- "$src" "$dst"
  done
  rm -- "$old" "$new"
  lf -remote "send $id unselect"
}}

# name is different to avoid recursive calls
map p paste_try_cow
map ,r bulk-rename

# Source Bookmarks
source "~/.config/lf/shortcutrc"
